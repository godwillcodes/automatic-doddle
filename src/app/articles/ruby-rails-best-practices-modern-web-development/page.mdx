import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'Godwill Barasa',
  date: '2024-12-15',
  title: 'Ruby on Rails Best Practices for Modern Web Development',
  description:
    'From ActiveRecord optimization to API design, discover the Ruby and Rails patterns that have helped me build scalable, maintainable applications over 5+ years of development.',
}

export const metadata = {
  title: article.title,
  description: article.description,
  keywords: [
    'Ruby on Rails',
    'Ruby programming',
    'Rails best practices',
    'web development',
    'backend development',
    'API development',
    'ActiveRecord',
    'Rails performance',
    'Rails optimization',
    'Rails architecture'
  ],
  openGraph: {
    title: article.title,
    description: article.description,
    type: 'article',
    publishedTime: article.date,
    authors: [article.author],
    images: [
      {
        url: '/images/portrait.jpg',
        width: 1200,
        height: 630,
        alt: article.title,
      },
    ],
  },
  twitter: {
    card: 'summary_large_image',
    title: article.title,
    description: article.description,
    images: ['/images/portrait.jpg'],
  },
  alternates: {
    canonical: `/articles/${article.slug}`,
  },
}

export default (props) => <ArticleLayout article={article} {...props} />

Picture this: It's 2 AM, and I'm staring at a Rails application that's taking 8 seconds to load a simple user dashboard. The database is screaming, the memory usage is through the roof, and my coffee has gone cold for the third time. This isn't a nightmare â€“ this is what happens when you ignore Ruby on Rails best practices.

![Rails Performance Nightmare](https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif)

After 5+ years of building everything from high-traffic e-commerce platforms to complex fintech applications, I've learned that Rails isn't just a framework â€“ it's a philosophy. And like any good philosophy, it has rules that, when followed, can transform your code from a maintenance nightmare into a joy to work with.

![Rails Success](https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif)

Let me share the Ruby and Rails patterns that have saved my sanity (and my sleep schedule) over the years.

## The ActiveRecord Optimization Game

Let me start with a story that'll make you question everything you know about database queries. Last year, I inherited a Rails application that was supposed to display a list of users with their recent orders. Simple enough, right?

Wrong. The original code looked like this:

```ruby
# The performance killer
@users = User.all
@users.each do |user|
  user.orders.recent.limit(5) # N+1 query nightmare
end
```

This innocent-looking code was generating 1,001 database queries for 1,000 users. The page was taking 12 seconds to load, and users were abandoning ship faster than you can say "optimization."

Here's how I fixed it:

```ruby
# The performance hero
@users = User.includes(:orders)
             .where(orders: { created_at: 1.month.ago.. })
             .references(:orders)
```

One query. 0.2 seconds. Problem solved.

### The N+1 Query Prevention Playbook

The N+1 query problem is the Rails developer's arch-nemesis. Here's my battle-tested approach to defeating it:

**1. Use `includes` for associations you know you'll need:**
```ruby
# Good: Loads users and their orders in 2 queries
users = User.includes(:orders).where(active: true)

# Bad: Loads users, then orders for each user (N+1)
users = User.where(active: true)
users.each { |user| user.orders }
```

**2. Use `preload` when you need the association but not for filtering:**
```ruby
# Good: Loads users and their profiles separately
users = User.preload(:profile).where(active: true)

# Good: Loads users and their profiles in one query
users = User.includes(:profile).where(active: true)
```

**3. Use `joins` when you only need the association for filtering:**
```ruby
# Good: Only joins, doesn't load the association data
users = User.joins(:orders).where(orders: { status: 'completed' })
```

### The Counter Cache Conundrum

Here's a Rails pattern that's saved me countless hours: counter caches. Instead of counting associated records every time, store the count in the parent record.

```ruby
# Migration
add_column :users, :orders_count, :integer, default: 0

# Model
class User < ApplicationRecord
  has_many :orders, counter_cache: true
end

class Order < ApplicationRecord
  belongs_to :user, counter_cache: true
end

# Usage
user.orders_count # Fast database column read
# vs
user.orders.count # Slow COUNT(*) query
```

## The Service Object Saga

One of the biggest mistakes I see in Rails applications is putting business logic in controllers or models. Controllers should be thin, models should be focused, and business logic should live in service objects.

Here's a real example from a fintech application I built:

```ruby
# Bad: Fat controller
class OrdersController < ApplicationController
  def create
    @order = Order.new(order_params)
    
    if @order.valid?
      # Payment processing logic
      payment_result = PaymentGateway.charge(
        @order.total,
        @order.user.payment_method
      )
      
      if payment_result.success?
        # Inventory management
        @order.items.each do |item|
          item.product.decrement!(:stock_quantity, item.quantity)
        end
        
        # Email notifications
        OrderMailer.confirmation(@order).deliver_now
        OrderMailer.notify_admin(@order).deliver_now
        
        # Analytics tracking
        Analytics.track('order_created', {
          order_id: @order.id,
          total: @order.total,
          user_id: @order.user_id
        })
        
        @order.update!(status: 'confirmed')
        redirect_to @order, notice: 'Order created successfully!'
      else
        @order.errors.add(:payment, payment_result.error_message)
        render :new
      end
    else
      render :new
    end
  end
end
```

This controller is doing way too much. Here's how I refactored it using service objects:

```ruby
# Good: Thin controller
class OrdersController < ApplicationController
  def create
    @order = Order.new(order_params)
    
    result = OrderCreationService.new(@order).call
    
    if result.success?
      redirect_to @order, notice: 'Order created successfully!'
    else
      @order.errors.merge!(result.errors)
      render :new
    end
  end
end

# Service object
class OrderCreationService
  def initialize(order)
    @order = order
  end
  
  def call
    return failure(@order.errors) unless @order.valid?
    
    ActiveRecord::Base.transaction do
      process_payment
      update_inventory
      send_notifications
      track_analytics
      confirm_order
    end
    
    success(@order)
  rescue => e
    failure([e.message])
  end
  
  private
  
  def process_payment
    result = PaymentGateway.charge(@order.total, @order.user.payment_method)
    raise PaymentError, result.error_message unless result.success?
  end
  
  def update_inventory
    @order.items.each do |item|
      item.product.decrement!(:stock_quantity, item.quantity)
    end
  end
  
  def send_notifications
    OrderMailer.confirmation(@order).deliver_now
    OrderMailer.notify_admin(@order).deliver_now
  end
  
  def track_analytics
    Analytics.track('order_created', {
      order_id: @order.id,
      total: @order.total,
      user_id: @order.user_id
    })
  end
  
  def confirm_order
    @order.update!(status: 'confirmed')
  end
  
  def success(order)
    OpenStruct.new(success?: true, order: order)
  end
  
  def failure(errors)
    OpenStruct.new(success?: false, errors: errors)
  end
end
```

## The Form Object Pattern

Rails forms are powerful, but they can get messy when you need to handle complex data or multiple models. That's where form objects come in.

```ruby
# Form object
class UserRegistrationForm
  include ActiveModel::Model
  include ActiveModel::Attributes
  
  attribute :email, :string
  attribute :password, :string
  attribute :password_confirmation, :string
  attribute :first_name, :string
  attribute :last_name, :string
  attribute :company_name, :string
  attribute :terms_accepted, :boolean
  
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :password, presence: true, length: { minimum: 8 }
  validates :password_confirmation, presence: true
  validates :first_name, presence: true
  validates :last_name, presence: true
  validates :terms_accepted, acceptance: true
  
  validate :passwords_match
  
  def save
    return false unless valid?
    
    ActiveRecord::Base.transaction do
      create_user
      create_company
      send_welcome_email
    end
    
    true
  rescue => e
    errors.add(:base, e.message)
    false
  end
  
  private
  
  def passwords_match
    return if password == password_confirmation
    errors.add(:password_confirmation, "doesn't match password")
  end
  
  def create_user
    @user = User.create!(
      email: email,
      password: password,
      first_name: first_name,
      last_name: last_name
    )
  end
  
  def create_company
    @user.create_company!(name: company_name)
  end
  
  def send_welcome_email
    UserMailer.welcome(@user).deliver_now
  end
end

# Controller
class RegistrationsController < ApplicationController
  def new
    @form = UserRegistrationForm.new
  end
  
  def create
    @form = UserRegistrationForm.new(registration_params)
    
    if @form.save
      redirect_to dashboard_path, notice: 'Welcome!'
    else
      render :new
    end
  end
  
  private
  
  def registration_params
    params.require(:user_registration_form).permit(
      :email, :password, :password_confirmation,
      :first_name, :last_name, :company_name, :terms_accepted
    )
  end
end
```

## The Query Object Pattern

When your model methods start getting complex, it's time to extract them into query objects.

```ruby
# Query object
class UserSearchQuery
  def initialize(params = {})
    @params = params
  end
  
  def call
    users = User.all
    
    users = filter_by_status(users)
    users = filter_by_role(users)
    users = filter_by_date_range(users)
    users = search_by_name(users)
    users = sort_users(users)
    
    users
  end
  
  private
  
  def filter_by_status(users)
    return users unless @params[:status].present?
    users.where(status: @params[:status])
  end
  
  def filter_by_role(users)
    return users unless @params[:role].present?
    users.where(role: @params[:role])
  end
  
  def filter_by_date_range(users)
    return users unless @params[:date_from].present? || @params[:date_to].present?
    
    users = users.where('created_at >= ?', @params[:date_from]) if @params[:date_from].present?
    users = users.where('created_at <= ?', @params[:date_to]) if @params[:date_to].present?
    
    users
  end
  
  def search_by_name(users)
    return users unless @params[:search].present?
    
    search_term = "%#{@params[:search]}%"
    users.where(
      'first_name ILIKE ? OR last_name ILIKE ? OR email ILIKE ?',
      search_term, search_term, search_term
    )
  end
  
  def sort_users(users)
    return users unless @params[:sort].present?
    
    case @params[:sort]
    when 'name_asc'
      users.order(:first_name, :last_name)
    when 'name_desc'
      users.order(first_name: :desc, last_name: :desc)
    when 'created_at_desc'
      users.order(created_at: :desc)
    else
      users
    end
  end
end

# Usage in controller
class UsersController < ApplicationController
  def index
    @users = UserSearchQuery.new(search_params).call
  end
  
  private
  
  def search_params
    params.permit(:status, :role, :date_from, :date_to, :search, :sort)
  end
end
```

## The Background Job Best Practices

Background jobs are essential for keeping your Rails application responsive, but they can be tricky to get right. Here are the patterns that have served me well:

### 1. Make Jobs Idempotent

```ruby
# Good: Idempotent job
class SendWelcomeEmailJob < ApplicationJob
  def perform(user_id)
    user = User.find(user_id)
    
    # Check if email was already sent
    return if user.welcome_email_sent?
    
    UserMailer.welcome(user).deliver_now
    user.update!(welcome_email_sent_at: Time.current)
  end
end

# Bad: Not idempotent
class SendWelcomeEmailJob < ApplicationJob
  def perform(user_id)
    user = User.find(user_id)
    UserMailer.welcome(user).deliver_now # Could send multiple emails
  end
end
```

### 2. Handle Failures Gracefully

```ruby
class ProcessPaymentJob < ApplicationJob
  retry_on PaymentGateway::TimeoutError, wait: :exponentially_longer, attempts: 3
  retry_on PaymentGateway::RateLimitError, wait: 30.seconds, attempts: 5
  
  discard_on PaymentGateway::InvalidCardError do |job, error|
    # Log the error and notify the user
    Rails.logger.error "Payment failed for user #{job.arguments.first}: #{error.message}"
    UserMailer.payment_failed(job.arguments.first).deliver_now
  end
  
  def perform(order_id)
    order = Order.find(order_id)
    PaymentGateway.charge(order.total, order.user.payment_method)
  end
end
```

### 3. Use Job Dependencies Wisely

```ruby
# Good: Chain related jobs
class OrderProcessingJob < ApplicationJob
  def perform(order_id)
    order = Order.find(order_id)
    
    # Process payment
    ProcessPaymentJob.perform_now(order_id)
    
    # Update inventory
    UpdateInventoryJob.perform_now(order_id)
    
    # Send notifications
    SendOrderConfirmationJob.perform_later(order_id)
    NotifyAdminJob.perform_later(order_id)
    
    # Track analytics
    TrackOrderAnalyticsJob.perform_later(order_id)
  end
end
```

## The API Design Philosophy

Building APIs in Rails is an art form. Here's how I structure my API controllers for maximum maintainability:

```ruby
# API Controller base class
class Api::V1::BaseController < ApplicationController
  before_action :authenticate_user!
  before_action :set_default_response_format
  
  rescue_from ActiveRecord::RecordNotFound, with: :not_found
  rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
  rescue_from StandardError, with: :internal_server_error
  
  private
  
  def set_default_response_format
    request.format = :json
  end
  
  def not_found(exception)
    render json: { error: 'Resource not found' }, status: :not_found
  end
  
  def unprocessable_entity(exception)
    render json: { 
      error: 'Validation failed', 
      details: exception.record.errors.full_messages 
    }, status: :unprocessable_entity
  end
  
  def internal_server_error(exception)
    Rails.logger.error exception.message
    Rails.logger.error exception.backtrace.join("\n")
    
    render json: { error: 'Internal server error' }, status: :internal_server_error
  end
end

# Specific API controller
class Api::V1::UsersController < Api::V1::BaseController
  before_action :set_user, only: [:show, :update, :destroy]
  
  def index
    @users = UserSearchQuery.new(search_params).call
    render json: UserSerializer.new(@users).serialized_json
  end
  
  def show
    render json: UserSerializer.new(@user).serialized_json
  end
  
  def create
    @user = User.new(user_params)
    
    if @user.save
      render json: UserSerializer.new(@user).serialized_json, status: :created
    else
      render json: { 
        error: 'Validation failed', 
        details: @user.errors.full_messages 
      }, status: :unprocessable_entity
    end
  end
  
  def update
    if @user.update(user_params)
      render json: UserSerializer.new(@user).serialized_json
    else
      render json: { 
        error: 'Validation failed', 
        details: @user.errors.full_messages 
      }, status: :unprocessable_entity
    end
  end
  
  def destroy
    @user.destroy
    head :no_content
  end
  
  private
  
  def set_user
    @user = User.find(params[:id])
  end
  
  def user_params
    params.require(:user).permit(:email, :first_name, :last_name, :role)
  end
  
  def search_params
    params.permit(:status, :role, :search, :sort, :page, :per_page)
  end
end
```

## The Testing Strategy That Actually Works

Testing in Rails can be overwhelming, but here's the strategy that has consistently delivered reliable applications:

### 1. The Testing Pyramid

```ruby
# Unit tests (fast, isolated)
class UserTest < ActiveSupport::TestCase
  test "should create user with valid attributes" do
    user = User.new(email: "test@example.com", password: "password123")
    assert user.valid?
  end
  
  test "should not create user without email" do
    user = User.new(password: "password123")
    assert_not user.valid?
    assert_includes user.errors[:email], "can't be blank"
  end
end

# Integration tests (medium speed, test interactions)
class UserRegistrationTest < ActionDispatch::IntegrationTest
  test "should create user and send welcome email" do
    assert_difference 'User.count' do
      post users_path, params: {
        user: {
          email: "test@example.com",
          password: "password123",
          password_confirmation: "password123"
        }
      }
    end
    
    assert_redirected_to dashboard_path
    assert_equal 1, ActionMailer::Base.deliveries.size
  end
end

# System tests (slow, test full user flows)
class UserRegistrationSystemTest < ApplicationSystemTestCase
  test "user can register and access dashboard" do
    visit new_user_registration_path
    
    fill_in "Email", with: "test@example.com"
    fill_in "Password", with: "password123"
    fill_in "Password confirmation", with: "password123"
    
    click_button "Create Account"
    
    assert_text "Welcome to the dashboard!"
    assert_current_path dashboard_path
  end
end
```

### 2. The Factory Pattern

```ruby
# Factory definition
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { "password123" }
    first_name { Faker::Name.first_name }
    last_name { Faker::Name.last_name }
    
    trait :admin do
      role { "admin" }
    end
    
    trait :with_orders do
      after(:create) do |user|
        create_list(:order, 3, user: user)
      end
    end
  end
  
  factory :order do
    user
    total { Faker::Commerce.price(range: 10.0..100.0) }
    status { "pending" }
    
    trait :completed do
      status { "completed" }
      completed_at { 1.day.ago }
    end
  end
end

# Usage in tests
class OrderTest < ActiveSupport::TestCase
  test "should calculate total correctly" do
    user = create(:user, :with_orders)
    order = create(:order, :completed, user: user)
    
    assert order.total > 0
  end
end
```

## The Performance Monitoring Mindset

Performance monitoring isn't just about fixing slow queries â€“ it's about understanding how your application behaves in the real world.

### 1. Use Rails Performance Tools

```ruby
# Gemfile
gem 'rack-mini-profiler'
gem 'memory_profiler'
gem 'stackprof'

# Application configuration
if Rails.env.development?
  require 'rack-mini-profiler'
  Rack::MiniProfilerRails.initialize!(Rails.application)
end
```

### 2. Monitor Key Metrics

```ruby
# Application controller
class ApplicationController < ActionController::Base
  around_action :monitor_performance
  
  private
  
  def monitor_performance
    start_time = Time.current
    
    yield
    
    duration = Time.current - start_time
    
    if duration > 1.second
      Rails.logger.warn "Slow request: #{request.path} took #{duration}s"
    end
    
    # Track metrics
    StatsD.timing("rails.request.duration", duration * 1000)
    StatsD.increment("rails.request.count")
  end
end
```

## The Deployment and DevOps Dance

Rails applications need proper deployment strategies. Here's what I've learned:

### 1. Environment-Specific Configuration

```ruby
# config/environments/production.rb
Rails.application.configure do
  # Performance
  config.cache_classes = true
  config.eager_load = true
  config.consider_all_requests_local = false
  config.public_file_server.enabled = ENV['RAILS_SERVE_STATIC_FILES'].present?
  
  # Caching
  config.cache_store = :redis_cache_store, { url: ENV['REDIS_URL'] }
  
  # Logging
  config.log_level = :info
  config.log_tags = [:request_id]
  
  # Assets
  config.assets.compile = false
  config.assets.digest = true
  
  # Security
  config.force_ssl = true
  config.ssl_options = { redirect: { exclude: -> request { request.path =~ /health/ } } }
end
```

### 2. Database Optimization

```ruby
# config/database.yml
production:
  adapter: postgresql
  url: <%= ENV['DATABASE_URL'] %>
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000
  connect_timeout: 2
  checkout_timeout: 5
  reaping_frequency: 10
  idle_timeout: 300
```

## The Bottom Line: Rails Wisdom

After 5+ years of building Rails applications, here's what I've learned:

1. **Rails is opinionated for a reason** â€“ follow the conventions, and you'll be productive
2. **Performance is a feature** â€“ optimize early and often
3. **Testing is not optional** â€“ it's your safety net
4. **Service objects are your friends** â€“ keep controllers thin and models focused
5. **Background jobs are essential** â€“ don't make users wait for slow operations
6. **Monitoring is crucial** â€“ you can't fix what you can't measure

The beauty of Rails is that it gives you the tools to build amazing applications quickly, but it also gives you enough rope to hang yourself if you're not careful. The patterns I've shared here are the ones that have helped me build applications that are not just functional, but maintainable, performant, and a joy to work with.

So, whether you're building your first Rails app or your hundredth, remember: good Rails code is not just about making it work â€“ it's about making it work well, for a long time, with a team of developers who will thank you for your thoughtful architecture.

## Stay Weird ðŸš€

As I wrap up this deep dive into Ruby and Rails best practices, I'm reminded of why I love this framework. It's not just about the code â€“ it's about the community, the conventions, and the philosophy of building applications that are both powerful and elegant.

The patterns I've shared here aren't just technical solutions â€“ they're the result of years of learning from mistakes, reading great code, and working with amazing teams. They're the patterns that have helped me build applications that scale, that are maintainable, and that developers actually enjoy working on.

So, whether you're just starting your Rails journey or you're a seasoned developer looking to level up your game, remember: the best Rails code is the code that makes the next developer's job easier, not harder.

Stay weird, stay curious, and keep building amazing things with Ruby and Rails.

[Reach out to me on Twitter](https://twitter.com/godwill_codes)

[Connect with me on LinkedIn](https://www.linkedin.com/in/godwillcodes/)

[Instagram, for the baddies](https://www.instagram.com/godwill.codes)

[Github, for the geeks](https://github.com/godwillcodes)
